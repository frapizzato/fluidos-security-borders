Namespace creation:
kubectl create namespace fluidos
kubectl create namespace monitoring
kubectl label namespace fluidos name=fluidos
kubectl label namespace monitoring name=monitoring
kubectl label namespace default name=default
------------------------------------------------------------------------------------------
Service account creation
kubectl create service-account traslator-service-account

We have to apply all the file in the Service Account folder:
kubectl apply -f secret.yaml
kubectl apply -f create-networkpolicies-clusterrole.yaml
kubectl apply -f create-networkpolicies-clusterrolebinding.yaml
kubectl apply -f list-namespaces-cluster-role.yaml
kubectl apply -f list-namespaces-cluster-role-binding.yaml
kubectl apply -f list-pods-cluster-role.yaml
kubectl apply -f list-pods-cluster-role-binding.yaml

Extraction of the token:
kubectl get secret traslator-service-account -o jsonpath='{.data.token}' | base64 --decode
------------------------------------------------------------------------------------------
Deployments creation:
kubectl apply -f bank-payment-deployment.yaml
kubectl apply -f order-placement-deployment.yaml
kubectl apply -f resource-monitor-deployment.yaml
kubectl apply -f test-authorizationmandatory-deployment.yaml
kubectl apply -f product-catalogue-deployment.yaml
-----------------------------------------------------------------------------
To see the ClusterIP type:
kubectl get services -n "namespace"
------------------------------------------------------------------------------------------
To see the PodID name type:
kubectl get pods -n "namespace"
-------------------------------------------------------------------------------------------
Test policy request intent 1 (from "app:order_placement" to "app:product_catalogue", ALL)

Expose product-catalogue as a K8S service:
kubectl expose --namespace=default deployment product-catalogue --port=80

Testing connectivity from order_placement to product_catalogue:
kubectl exec -it *PodIDOrderPlacement* -n fluidos  -- /bin/sh
wget *ClusterIPProductCatalogue*
-------------------------------------------------------------------------------------------

Test policy request intent 2 (from "app:bank_payment" to ANY (namespace default), ALL)
I re-used product_catalogue that is already deployed in the default namespace.

kubectl exec -it *PodIDBank_payment* -n fluidos  -- /bin/sh
wget *ClusterIPProductCatalogue*

-------------------------------------------------------------------------------------------
Test policy request intent 3 (<!-- from "app:bank_payment" to 0.0.0.0/0, ALL -->)

kubectl exec -it *PodIDBank_payment* -n fluidos  -- /bin/sh
wget -q --timeout=5 google.com -O -

------------------------------------------------------------------------------------------------------

Test policy request intent 4 (<!-- from ANY ("monitoring") to "app:order_placement", ALL  -->))
Expose order-placement as a K8S service:
kubectl expose --namespace=fluidos deployment order-placement --port=80

kubectl exec -it *PodIDResourceMonitor* -n monitoring  -- /bin/sh
wget *ClusterIPdiorder_placement*

-------------------------------------------------------------------------------------------------------

Test della policy authorizationmandatory (<!-- from "app:resource_monitor" to ANY:43, TCP  -->)

Exposing the test authorizationmandatory deployment on the port 43
kubectl expose --namespace=fluidos deployment test --port=43

kubectl exec -it *PodIDResourceMonitor* -n monitoring  -- /bin/sh
telnet "ClusterIPTest" 43    (before the application of the policy the command is not returning and enters in a loop, 
after the application of the policy the connection will be refused but the pod is reachable, that means the policy works)

-----------------------------------------------------------------------------------------------------------------------